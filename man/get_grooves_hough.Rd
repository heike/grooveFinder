% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_grooves_hough.R
\name{get_grooves_hough}
\alias{get_grooves_hough}
\title{Use Hough transformation to identify groove locations.}
\usage{
get_grooves_hough(land, norm.index = 1, adjust = 10, return_plot = FALSE)
}
\arguments{
\item{land}{Either a dataframe of surface measurements in microns in the x, y, and x direction, or an x3p file. Use `x3p_to_df` to access the data from an x3p scan.}

\item{norm.index}{positive number index to indicate which of the ordered normalized hough scores should be used to estimate the grooves area}

\item{adjust}{(generally) positive number in micron used to adjust the grooves inward}

\item{return_plot}{boolean value - should a plot of the crosscut with the grooves be returned? defaults to FALSE}
}
\value{
list object consisting of functions to describe the left and right groove.
Parameters for the functions are given in microns and return results in microns.
}
\description{
Hough transformations are used to identify the location of left and right groove.
Generates Hough lines
and selects lines with angle corresponding to (close to) vertical lines.
}
\examples{
library(x3ptools)
library(ggplot2)


x3p <- br411

# Get grooves fit for left and right groove from x3p
grooves <- get_grooves_hough(x3p_to_df(x3p))

# Find optimized crosscut location, this may take some time
# if (require(bulletxtrctr)) {
# crosscut <- x3p \%>\% bulletxtrctr::x3p_crosscut_optimize()
# } else {
crosscut <- 125
# }
\dontrun{
a <- get_mask_hough(x3p, grooves)
a <- a \%>\% x3p_add_hline(yintercept = crosscut)
x3ptools::image_x3p(a)
}

# Find groove locations for specified crosscut
grooves$left.groove.fit(crosscut)
grooves$right.groove.fit(crosscut)

# Plot profile
ccdata <- x3p \%>\%
  x3p_to_df() \%>\%
  dplyr::filter(y == crosscut)

ccdata \%>\%
  ggplot(aes(x = x, y = value)) +
  geom_line() +
  geom_vline(xintercept = grooves$left.groove.fit(crosscut), color = "red") +
  geom_vline(xintercept = grooves$right.groove.fit(crosscut), color = "blue")

# grooves at a different crosscut:
x3p \%>\%
  x3p_to_df() \%>\%
  dplyr::filter(y == 150) \%>\%
  ggplot(aes(x = x, y = value)) +
  geom_line() +
  geom_vline(xintercept = grooves$left.groove.fit(crosscut), color = "red") +
  geom_vline(xintercept = grooves$right.groove.fit(crosscut), color = "blue")
}
